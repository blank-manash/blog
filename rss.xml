<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Emacsome</title><link>https://blank-manash.github.io/blog/</link><description>A Technical Blog About On Software and Mathematics</description><atom:link href="https://blank-manash.github.io/blog/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2023 &lt;a href="mailto:mximpaid@gmail.com"&gt;Manash Baul&lt;/a&gt; </copyright><lastBuildDate>Sun, 18 Jun 2023 19:38:44 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Rate Limiter</title><link>https://blank-manash.github.io/blog/posts/rate-limiter/</link><dc:creator>Manash Baul</dc:creator><description>&lt;div id="outline-container-orgb6250a0" class="outline-2"&gt;
&lt;h2 id="orgb6250a0"&gt;Rate Limiter: The Why?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb6250a0"&gt;
&lt;p&gt;
Rate Limiters are fundamental tools in order to facilitate security measures against DDoS attacks. It also helps in managing cost, regulate QPS and render deterministic expections on the usage of our system. Almost all the services you know today have a Rate Limiter Service in place, which is also offered within your Cloud Subscription if you are hosting behind a Cloud Server.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org40e3a83" class="outline-2"&gt;
&lt;h2 id="org40e3a83"&gt;Rate Limiter: The How?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org40e3a83"&gt;
&lt;p&gt;
Sure it seems simple enough to implement a Rate Limiting, with the requirements as simple as
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Only an &lt;code&gt;x&lt;/code&gt; number of requests are allowed from a host / IP / user per minute.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
But as always, there are some caveats, and this blog is about that caveats. To being with, let's look at how we can implement such a service. We are assuming the rate limiter service will be included as an middleware with the API Gateway which redirects requests to the web server.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9b3c284" class="outline-3"&gt;
&lt;h3 id="org9b3c284"&gt;Token Buckets&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9b3c284"&gt;
&lt;p&gt;
Imagine we have a bucket, and we have it filled with some coins. Each request to pass through, requires 1 coin from it's bucket. If the bucket is empty, we drop the request. We also add a constant number of coins every second.
&lt;/p&gt;

&lt;p&gt;
Here is a simple implementation. We used id as the identifier on how we are limiting the requests (example: IP)
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;passRequest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Bucket&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bucket&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buckets&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;bucket&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Although being simple and effective, the idea has a major flaw. It's is highly &lt;b&gt;resource intensive&lt;/b&gt; as we would need a to create a bucket for every &lt;code&gt;id&lt;/code&gt; and constantly refill all of the buckets in parallel. Due to such constraints it is an infeasible approach for a large scale system.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9c17ced" class="outline-3"&gt;
&lt;h3 id="org9c17ced"&gt;Leaky Buckets&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9c17ced"&gt;
&lt;p&gt;
The idea is same, however instead of refilling the bucket every second, we replace the entire bucket with a queue. The queue has a fixed capacity, and for every request that comes in, we check if the queue is in capacity. If it is, we drop the request.
&lt;/p&gt;

&lt;p&gt;
This is a much better approach then the previous one as we don't have to constanty fill the bucket. And the outflow rate is the number of request processed per second. Do consider that this algorithm has a fixed rate of processing the request. And a sudden burst of traffic could cause the new requests to stall.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb0a7eb6" class="outline-3"&gt;
&lt;h3 id="orgb0a7eb6"&gt;Sliding Window Log Algorithm&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb0a7eb6"&gt;
&lt;p&gt;
This is the first approach that came to me when I first looked at the problem statement. The idea is same as before, to create a queue, but of timestamps.
&lt;/p&gt;

&lt;p&gt;
For every request that comes, we do the following operation
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Append the timestamp of the request to the queue.&lt;/li&gt;
&lt;li&gt;Delete obsolete timestamps from queue.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Obsolete Timestamps: &lt;i&gt;Timestamp with time less than current start interval&lt;/i&gt;
Typically that would mean if we are limiting by 1 min, then all the timestamps less than 1 min of current request would be removed from the queue.
&lt;/p&gt;

&lt;p&gt;
This is a deterministic algorithm will accurate results. This doesn't impose a fixed rate of request consumption, as requests are served as they come. However storing timestamps for all the requests can be memory intensive, especially when scaled to a large number of users.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5138641" class="outline-3"&gt;
&lt;h3 id="org5138641"&gt;Sliding Window Count Algorithm&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5138641"&gt;
&lt;p&gt;
This is tweak on the above algorithm, with making it probabilistic but with very low probablity of error, and much simpler implemention.
We take a assumption that the rate of request is uniform over a window. And we keep a count only for the total number of requests recieved for the current window, and previous window. That's only two variables for each user.
&lt;/p&gt;

&lt;p&gt;
Now the trick, we count the total number of request of an interval as &lt;code&gt;x * a + y * b&lt;/code&gt;.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;: Percentage of overlap of the last window.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;: Number of requests recieved in the last window.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt;: Percentage of overlap of the current window.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;: Number of requests recieved in the current window.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
If you look at it, you would recognize it as a running average of the number of requests received. And this works very nicely for real world usecase. According to experiments, it has a 0.003% of requests wrongly allowed done over 400 million requests. (Cloudfare)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb123308" class="outline-2"&gt;
&lt;h2 id="orgb123308"&gt;Rate Limiter: The Caveats&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb123308"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgaec29ce" class="outline-3"&gt;
&lt;h3 id="orgaec29ce"&gt;Synchronization&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgaec29ce"&gt;
&lt;p&gt;
We could have too many requests for one rate limiter server to handle, for which we would need add multiple rate-limiter servers to filter requests. This would add the problem of data synchronization. Every request can go to random rate limiter which will make it diffcult to maintain the count of recieved request. One solution is to introduce sticky sessions where clients are redirected to a specific server for every server, but is easily isn't the best solution available.
&lt;/p&gt;

&lt;p&gt;
The better approach is to use a cache or a database where the servers can connect to store client information. With this way information is decoupled with processing, allowing them to integrate independently.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgcd9b8a6" class="outline-3"&gt;
&lt;h3 id="orgcd9b8a6"&gt;Race Conditions&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgcd9b8a6"&gt;
&lt;p&gt;
For any of the above approaches, we would need to store data in a centralized data storage. This introduces the problem of race condition. Say two requests from a user came at the same time. We would first check the counter of user at the same time. Which will return the same value for both of the requests, (as they are read at the same time) which will allow the request to be incorrectly updated with +1 instead of +2.
&lt;/p&gt;

&lt;p&gt;
A common solution to this problem is making the process atmoic. We can achieve this using lua scripts. Redis allows us to lua scripts as a mean of multi commands. Instead of putting the read&lt;sub&gt;counter&lt;/sub&gt; and check&lt;sub&gt;and&lt;/sub&gt;&lt;sub&gt;update&lt;/sub&gt; functions in the application logic, we can delegate them to redis script to read and update at the same time for each request. This would allow atomicity and handle race conditions.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb25a862" class="outline-2"&gt;
&lt;h2 id="orgb25a862"&gt;Conclusion&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb25a862"&gt;
&lt;p&gt;
Never thought a simple queue would have such a list of details to explain for a simple functionality. But it's interesting to see the problems arise in a distributed system. Designing such system generally pose the problems of consistency and availabity. And a rate limiter, by a simple design isn't free of it either.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://blank-manash.github.io/blog/posts/rate-limiter/</guid><pubDate>Sun, 18 Jun 2023 19:38:08 GMT</pubDate></item><item><title>Am I back?</title><link>https://blank-manash.github.io/blog/posts/am-i-back/</link><dc:creator>Manash Baul</dc:creator><description>&lt;div id="outline-container-org5f05779" class="outline-2"&gt;
&lt;h2 id="org5f05779"&gt;Am I back?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5f05779"&gt;
&lt;p&gt;
I am back to blogging after a long time. I have been busy with my work and a long time dissimilarity of leaving the world of linux to find other systems that the world. So I started to learn System Design in order to facilitate myself with all the other ways. I want to revive this blog as I no longer wonder about math support to be added.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgca0b6a8" class="outline-3"&gt;
&lt;h3 id="orgca0b6a8"&gt;How to revive this blog?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgca0b6a8"&gt;
&lt;p&gt;
Admittedly, it was a big of discovery to find out how this blog actually worked. But to make sure that I can have it up and running again. Here is a bit of heads up on how to achieve that quick.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0237d8b" class="outline-4"&gt;
&lt;h4 id="org0237d8b"&gt;Step 1: The Repository&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0237d8b"&gt;
&lt;p&gt;
The repository is set up in &lt;code&gt;blank-manash/blog&lt;/code&gt;. To start, simply clone it to your system. It contains 2 branches, &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;main&lt;/code&gt;, the src is where we would be actively working on, and the &lt;code&gt;main&lt;/code&gt; is from where the pages are published. Make sure you are checked out to the &lt;code&gt;src&lt;/code&gt; branch when you are working on this.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org265cab5" class="outline-4"&gt;
&lt;h4 id="org265cab5"&gt;Step 2: Nikola&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org265cab5"&gt;
&lt;p&gt;
Install Nikola. The offical website asks you to install it using a venv. But the direct install through homebrew on my macbook works fine as well. Everything is already set up, you would want to run these commands.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip3 install nikola ghp-import
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org25e29f8" class="outline-4"&gt;
&lt;h4 id="org25e29f8"&gt;Step 3: Edit&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org25e29f8"&gt;
&lt;p&gt;
Now you can simply get started by creating a new page from &lt;code&gt;nikola new_post -e&lt;/code&gt;, &lt;code&gt;nikola build&lt;/code&gt;, &lt;code&gt;nikola serve -b&lt;/code&gt; and &lt;code&gt;nikola github_deploy&lt;/code&gt;. It's self explanatory of what these things mean, but it really is that easy to get started with it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://blank-manash.github.io/blog/posts/am-i-back/</guid><pubDate>Sat, 17 Jun 2023 12:00:44 GMT</pubDate></item><item><title>Emacs Blogging</title><link>https://blank-manash.github.io/blog/posts/emacs-blogging%20/</link><dc:creator>Manash Baul</dc:creator><description>&lt;div id="outline-container-org1347462" class="outline-2"&gt;
&lt;h2 id="org1347462"&gt;How I finally made a blog with org-mode.&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1347462"&gt;
&lt;p&gt;
When I started off with development, one of the first tasks that you are typically supposed to do is make a blog. Me, a first year undergraduate completely new to the world of programming was handed a bunch of &lt;code&gt;.js&lt;/code&gt; files with the expectation to build a blog out of it.
&lt;/p&gt;

&lt;p&gt;
And I did, eventually.
&lt;/p&gt;

&lt;p&gt;
Except for the tweaks in CSS, which I stole from other websites. There were massive problems with that blog.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;It didn't scale well&lt;/li&gt;
&lt;li&gt;If you added a blog, the text didn't wrap properly.&lt;/li&gt;
&lt;li&gt;The interface to add a blog was, 1940s to say the least.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Nevertheless, that project didn't go well, and my hopes of writing amazing technical blogs to share my infant JavaScript knowledge lies rested in my &lt;code&gt;~/web-dev/projects/blog&lt;/code&gt; folder.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7543c6d" class="outline-2"&gt;
&lt;h2 id="org7543c6d"&gt;Static Site builders.&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7543c6d"&gt;
&lt;p&gt;
A great concept in itself, maybe you are using &lt;code&gt;Jekyll, Hugo&lt;/code&gt; or maybe even &lt;code&gt;react&lt;/code&gt; to build yours, but I had my handful of journey coming here.
&lt;/p&gt;

&lt;p&gt;
I was introduced to &lt;code&gt;markdown&lt;/code&gt; pretty soon. Every developer has to make one. But I also had the requirement of introducing math in it, which made a bit difficult to the right software I need. 
&lt;/p&gt;

&lt;p&gt;
I tried &lt;code&gt;Jekyll&lt;/code&gt; and &lt;code&gt;Hugo&lt;/code&gt; both, but both of them, despite being excellent software felt a little bloated. A lot of directories, and template make a mess of what a simple requirement I had, write and post.
&lt;/p&gt;

&lt;p&gt;
I did found an old school solution called &lt;a href="https://dynalon.github.io/mdwiki/#!quickstart.md"&gt;MDWiki&lt;/a&gt;, which to be honest is pretty great, and was my preferred way to deploy something in case I want a quick web page. But then I met something else,
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org21dc4d5" class="outline-3"&gt;
&lt;h3 id="org21dc4d5"&gt;Enter Org-Mode&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org21dc4d5"&gt;
&lt;p&gt;
Org-Mode is the single most transformable dictating software that make you want to put your plain life in a plain text, but with markup and extra features to keep you satisfied.
&lt;/p&gt;

&lt;p&gt;
It's feels like a home in its self, whether is &lt;i&gt;coding, documentation, planning, thinking, journal&lt;/i&gt; or even all of that together. Org will be there, org will be your best partner in this.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5743347" class="outline-3"&gt;
&lt;h3 id="org5743347"&gt;Nikola&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5743347"&gt;
&lt;p&gt;
The plugin &lt;a href="https://github.com/getnikola/nikola"&gt;Nikola&lt;/a&gt;, was like godsend to me in writing a blog. It's painstakingly simple, almost to the point you start arguing how that's possible. There simple to use &lt;code&gt;CLI&lt;/code&gt; already makes things simpler, but since it's written in python, all the configuration files are simple dictionary which give you direct programmatic access to your variables, and there is no messy conversion of other format, even though that's possible if you may explicitly need it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf2eb20c" class="outline-2"&gt;
&lt;h2 id="orgf2eb20c"&gt;Putting it all together.&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf2eb20c"&gt;
&lt;p&gt;
All I need to do is install the &lt;a href="https://plugins.getnikola.com/v7/orgmode/"&gt;org-mode-plugin&lt;/a&gt;, edit the &lt;code&gt;conf.py&lt;/code&gt;, and boom. I can start writing blog posts. I changed my editor &lt;code&gt;export EDITOR="emacsclient -c"&lt;/code&gt; and there I can edit files in org easily.
&lt;/p&gt;

&lt;p&gt;
Furthermore, I still haven't integrated the whole method into Emacs, but I will use a bash script to automate all the process and bind them to commands in Emacs using &lt;code&gt;shell-command&lt;/code&gt; function, until I find a better way to learn more &lt;code&gt;elisp&lt;/code&gt; and write its independent function.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf145609" class="outline-2"&gt;
&lt;h2 id="orgf145609"&gt;References&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf145609"&gt;
&lt;p&gt;
There have been some inspirations to the whole method, primarily in no particular order,
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Reddit: For introducing me to &lt;code&gt;Nikola&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The Documentation for Nikola: &lt;a href="https://getnikola.com/documentation.html"&gt;Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Lincoln's Website &lt;a href="https://clarete.li/"&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>blogging</category><category>emacs</category><guid>https://blank-manash.github.io/blog/posts/emacs-blogging%20/</guid><pubDate>Wed, 08 Jun 2022 07:38:21 GMT</pubDate></item></channel></rss>